# HW04 Multitasking

## Tasks

### 4.1

Взять функцию подсчета чисел Фибоначчи и сравнить время исполнения кода (вызова функции от большого числа n (чтобы была видна разница в запусках на потоках и процессах) 10 раз, каждая на отдельном потоков\процессов) при использовании threading и multiprocessing. Запускаем одновременно 10 потоков/процессов, сравниваем общее время.
Необходимо сравнить время выполнения при синхронном запуске, использовании потоков и процессов.

Использовать concurrent.futures нельзя, задача про другое!
Артефакт - текстовый файл с результатами запуска различными методами.

#### Result
Получилось, что multithreading самый долгий. GIL запрещает параллельное исполнение нескольких потоков. Увеличение времени за счет добавления времени на создание потоков и переключения между ними.

Multiprocessing создает несколько процессов, в каждом из которых свой GIL. Они исполняются параллельно, поэтому получается быстрее.

### 4.2

Переписать функцию integrate для того, чтобы ее выполнение можно было распараллелить. Использовать concurrent.futures: ThreadPoolExecutor и ProcessPoolExecutor.  Сравнить время выполнения для integrate(math.cos, 0, math.pi / 2, n_jobs=n_jobs) при разном числе n_jobs (от 1 до cpu_num*2) при использовании ThreadPoolExecutor и ProcessPoolExecutor.

Артефакт - файл сравнения времени исполнения в обоих случаях в зависимости от числа воркеров

```python
import math
def integrate(f, a, b, *, n_jobs=1, n_iter=10000000):
    acc = 0
    step = (b - a) / n_iter
    for i in range(n_iter):
        acc += f(a + i * step) * step
    return acc
```


### 4.3
Реализовать следующую схему приложения:
У вас есть главный процесс и 2 дочерних (A и B). Из главного процесса вы можете через stdin отправлять сообщения (строки) в процесс A, которые будут складироваться в очередь. К каждому из сообщений процесс A будет применять .lower() и отправлять в процесс B (одно сообщение раз в 5 секунд). Процесс B должен отправлять закодированную строку через rot13, печатать в stdout и отправлять в отдельную очередь в главный процесс.
Вам понадобится как минимум multiprocessing.Queue, а возможно и  multiprocessing.Pipe и потоки.

Артефакт - текстовый файл взаимодействия вас и программы (необходимо выводить время сообщений)
